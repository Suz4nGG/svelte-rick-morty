(function () { const t = document.createElement('link').relList; if (t && t.supports && t.supports('modulepreload')) return; for (const r of document.querySelectorAll('link[rel="modulepreload"]'))o(r); new MutationObserver(r => { for (const c of r) if (c.type === 'childList') for (const i of c.addedNodes)i.tagName === 'LINK' && i.rel === 'modulepreload' && o(i) }).observe(document, { childList: !0, subtree: !0 }); function n (r) { const c = {}; return r.integrity && (c.integrity = r.integrity), r.referrerpolicy && (c.referrerPolicy = r.referrerpolicy), r.crossorigin === 'use-credentials' ? c.credentials = 'include' : r.crossorigin === 'anonymous' ? c.credentials = 'omit' : c.credentials = 'same-origin', c } function o (r) { if (r.ep) return; r.ep = !0; const c = n(r); fetch(r.href, c) } })(); function v () {} function D (e) { return e() } function B () { return Object.create(null) } function w (e) { e.forEach(D) } function G (e) { return typeof e === 'function' } function H (e, t) { return e != e ? t == t : e !== t || e && typeof e === 'object' || typeof e === 'function' } let x; function I (e, t) { return x || (x = document.createElement('a')), x.href = t, e === x.href } function X (e) { return Object.keys(e).length === 0 } function $ (e, t) { e.appendChild(t) } function p (e, t, n) { e.insertBefore(t, n || null) } function m (e) { e.parentNode.removeChild(e) } function Y (e, t) { for (let n = 0; n < e.length; n += 1)e[n] && e[n].d(t) } function _ (e) { return document.createElement(e) } function j (e) { return document.createTextNode(e) } function A () { return j(' ') } function M (e, t, n, o) { return e.addEventListener(t, n, o), () => e.removeEventListener(t, n, o) } function E (e, t, n) { n == null ? e.removeAttribute(t) : e.getAttribute(t) !== n && e.setAttribute(t, n) } function Z (e) { return Array.from(e.childNodes) } function ee (e, t) { t = '' + t, e.wholeText !== t && (e.data = t) } let S; function b (e) { S = e } const y = []; const T = []; const L = []; const F = []; const te = Promise.resolve(); let C = !1; function ne () { C || (C = !0, te.then(J)) } function P (e) { L.push(e) } const O = new Set(); let k = 0; function J () { const e = S; do { for (;k < y.length;) { const t = y[k]; k++, b(t), re(t.$$) } for (b(null), y.length = 0, k = 0; T.length;)T.pop()(); for (let t = 0; t < L.length; t += 1) { const n = L[t]; O.has(n) || (O.add(n), n()) }L.length = 0 } while (y.length); for (;F.length;)F.pop()(); C = !1, O.clear(), b(e) } function re (e) { if (e.fragment !== null) { e.update(), w(e.before_update); const t = e.dirty; e.dirty = [-1], e.fragment && e.fragment.p(e.ctx, t), e.after_update.forEach(P) } } const N = new Set(); let oe; function Q (e, t) { e && e.i && (N.delete(e), e.i(t)) } function ie (e, t, n, o) { if (e && e.o) { if (N.has(e)) return; N.add(e), oe.c.push(() => { N.delete(e), o && (n && e.d(1), o()) }), e.o(t) } else o && o() } function ce (e) { e && e.c() } function R (e, t, n, o) { const { fragment: r, after_update: c } = e.$$; r && r.m(t, n), o || P(() => { const i = e.$$.on_mount.map(D).filter(G); e.$$.on_destroy ? e.$$.on_destroy.push(...i) : w(i), e.$$.on_mount = [] }), c.forEach(P) } function U (e, t) { const n = e.$$; n.fragment !== null && (w(n.on_destroy), n.fragment && n.fragment.d(t), n.on_destroy = n.fragment = null, n.ctx = []) } function se (e, t) { e.$$.dirty[0] === -1 && (y.push(e), ne(), e.$$.dirty.fill(0)), e.$$.dirty[t / 31 | 0] |= 1 << t % 31 } function V (e, t, n, o, r, c, i, f = [-1]) { const l = S; b(e); const s = e.$$ = { fragment: null, ctx: [], props: c, update: v, not_equal: r, bound: B(), on_mount: [], on_destroy: [], on_disconnect: [], before_update: [], after_update: [], context: new Map(t.context || (l ? l.$$.context : [])), callbacks: B(), dirty: f, skip_bound: !1, root: t.target || l.$$.root }; i && i(s.root); let h = !1; if (s.ctx = n ? n(e, t.props || {}, (a, g, ...u) => { const d = u.length ? u[0] : g; return s.ctx && r(s.ctx[a], s.ctx[a] = d) && (!s.skip_bound && s.bound[a] && s.bound[a](d), h && se(e, a)), g }) : [], s.update(), h = !0, w(s.before_update), s.fragment = o ? o(s.ctx) : !1, t.target) { if (t.hydrate) { const a = Z(t.target); s.fragment && s.fragment.l(a), a.forEach(m) } else s.fragment && s.fragment.c(); t.intro && Q(e.$$.fragment), R(e, t.target, t.anchor, t.customElement), J() }b(l) } class W {$destroy () { U(this, 1), this.$destroy = v }$on (t, n) { if (!G(n)) return v; const o = this.$$.callbacks[t] || (this.$$.callbacks[t] = []); return o.push(n), () => { const r = o.indexOf(n); r !== -1 && o.splice(r, 1) } }$set (t) { this.$$set && !X(t) && (this.$$.skip_bound = !0, this.$$set(t), this.$$.skip_bound = !1) }} function K (e, t, n) { const o = e.slice(); return o[1] = t[n], o } function z (e) { let t; let n = e[1].name + ''; let o; let r; let c; let i; let f; return { c () { t = _('div'), o = j(n), r = A(), c = _('img'), I(c.src, i = e[1].image) || E(c, 'src', i), E(c, 'alt', f = e[1].name) }, m (l, s) { p(l, t, s), $(t, o), p(l, r, s), p(l, c, s) }, p (l, s) { s & 1 && n !== (n = l[1].name + '') && ee(o, n), s & 1 && !I(c.src, i = l[1].image) && E(c, 'src', i), s & 1 && f !== (f = l[1].name) && E(c, 'alt', f) }, d (l) { l && m(t), l && m(r), l && m(c) } } } function le (e) { let t; let n = e[0]; const o = []; for (let r = 0; r < n.length; r += 1)o[r] = z(K(e, n, r)); return { c () { t = _('div'); for (let r = 0; r < o.length; r += 1)o[r].c() }, m (r, c) { p(r, t, c); for (let i = 0; i < o.length; i += 1)o[i].m(t, null) }, p (r, [c]) { if (c & 1) { n = r[0]; let i; for (i = 0; i < n.length; i += 1) { const f = K(r, n, i); o[i] ? o[i].p(f, c) : (o[i] = z(f), o[i].c(), o[i].m(t, null)) } for (;i < o.length; i += 1)o[i].d(1); o.length = n.length } }, i: v, o: v, d (r) { r && m(t), Y(o, r) } } } function ue (e, t, n) { let { characters: o } = t; return e.$$set = r => { 'characters' in r && n(0, o = r.characters) }, [o] } class fe extends W {constructor (t) { super(), V(this, t, ue, le, H, { characters: 0 }) }} function ae (e) { let t, n, o, r, c, i, f, l, s, h, a, g; return s = new fe({ props: { characters: e[0] } }), { c () { t = _('div'), n = _('button'), o = j('Previous'), c = A(), i = _('button'), i.textContent = 'Next', f = A(), l = _('div'), ce(s.$$.fragment), n.disabled = r = e[1] === 1 }, m (u, d) { p(u, t, d), $(t, n), $(n, o), $(t, c), $(t, i), p(u, f, d), p(u, l, d), R(s, l, null), h = !0, a || (g = [M(n, 'click', e[3]), M(i, 'click', e[2])], a = !0) }, p (u, [d]) { (!h || d & 2 && r !== (r = u[1] === 1)) && (n.disabled = r); const q = {}; d & 1 && (q.characters = u[0]), s.$set(q) }, i (u) { h || (Q(s.$$.fragment, u), h = !0) }, o (u) { ie(s.$$.fragment, u), h = !1 }, d (u) { u && m(t), u && m(f), u && m(l), U(s), a = !1, w(g) } } } function de (e, t, n) { let o = []; let r = 1; async function c () { const s = await (await fetch(`https://rickandmortyapi.com/api/character?page=${r}`)).json(); n(0, o = s.results) } const i = () => { n(1, r++, r), c() }; const f = () => { n(1, r--, r), c() }; return c(), [o, r, i, f] } class he extends W {constructor (t) { super(), V(this, t, de, ae, H, {}) }} new he({ target: document.getElementById('app') })
